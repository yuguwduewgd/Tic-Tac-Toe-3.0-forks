<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OX Game (Tic-Tac-Toe)</title>
    
    <!-- INLINED CSS: Styling for a clean, responsive game board -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f4f8; /* Light background */
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 90%;
            max-width: 400px;
        }

        h1 {
            color: #1e3a8a;
            margin-bottom: 20px;
        }

        #status-message {
            margin: 15px 0;
            padding: 10px;
            border-radius: 6px;
            font-size: 1.2em;
            font-weight: 600;
            color: #007bff;
            background-color: #e3f2fd;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 100px);
            gap: 8px;
            margin: 20px auto;
        }
        
        @media (max-width: 450px) {
            .board {
                grid-template-rows: repeat(3, 80px);
            }
        }

        .cell {
            background-color: #ffffff;
            border: 2px solid #90cdf4;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .cell:hover:not(.x):not(.o) {
            background-color: #f7fafc;
        }

        /* Styles for the X and O */
        .cell.x {
            color: #e53e3e; /* Red */
        }

        .cell.o {
            color: #3182ce; /* Blue */
        }

        /* Options/Buttons Styling */
        #options-menu, #restart-button {
            margin-top: 20px;
        }

        select, button {
            padding: 12px 15px;
            margin-top: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            width: 100%;
            box-sizing: border-box;
            transition: background-color 0.1s;
        }

        button {
            background-color: #4c51bf; /* Indigo */
            color: white;
            border: none;
            box-shadow: 0 4px #36409d;
        }

        button:hover {
            background-color: #36409d;
        }
        
        button:active {
            box-shadow: 0 2px #36409d;
            transform: translateY(2px);
        }

        #ai-level-container {
            margin-top: 15px;
            padding: 15px;
            border: 1px dashed #a0aec0;
            border-radius: 8px;
            text-align: left;
        }
        #ai-level-container h2 {
            margin-top: 0;
            font-size: 1.1em;
            color: #2d3748;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>OX Game</h1>
        <div id="status-message">Select your game mode.</div>

        <!-- Options Menu -->
        <div id="options-menu">
            <h2>Game Mode</h2>
            <select id="game-mode">
                <option value="player-vs-player">Player vs Player</option>
                <option value="player-vs-ai">Player vs Computer (AI)</option>
            </select>

            <div id="ai-level-container" style="display: none;">
                <h2>AI Difficulty</h2>
                <select id="ai-level">
                    <option value="easy">Easy (Random)</option>
                    <option value="medium">Medium (Smart Blocking)</option>
                    <option value="hard">Hard (Unbeatable - Minimax)</option>
                </select>
            </div>
            
            <button onclick="startGame()">Start Game</button>
        </div>

        <!-- Game Board -->
        <div id="game-board" class="board" style="display: none;">
            <div class="cell" data-cell-index="0"></div>
            <div class="cell" data-cell-index="1"></div>
            <div class="cell" data-cell-index="2"></div>
            <div class="cell" data-cell-index="3"></div>
            <div class="cell" data-cell-index="4"></div>
            <div class="cell" data-cell-index="5"></div>
            <div class="cell" data-cell-index="6"></div>
            <div class="cell" data-cell-index="7"></div>
            <div class="cell" data-cell-index="8"></div>
        </div>

        <!-- Restart Button -->
        <button id="restart-button" style="display: none;" onclick="showOptionsMenu()">Change Mode / Reset</button>
    </div>

    <!-- INLINED JAVASCRIPT: Game Logic -->
    <script>
        // --- Game State Variables ---
        let board = ['', '', '', '', '', '', '', '', ''];
        let currentPlayer = 'X';
        let gameActive = false;
        let gameMode = 'player-vs-player';
        let aiLevel = 'easy';

        // DOM Elements
        const cells = document.querySelectorAll('.cell');
        const statusMessage = document.getElementById('status-message');
        const optionsMenu = document.getElementById('options-menu');
        const gameBoardElement = document.getElementById('game-board');
        const restartButton = document.getElementById('restart-button');
        const gameModeSelect = document.getElementById('game-mode');
        const aiLevelContainer = document.getElementById('ai-level-container');
        const aiLevelSelect = document.getElementById('ai-level');

        // Winning Conditions (Indices of the board array)
        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        // --- Initialization and Setup ---

        // Listener to show/hide AI level options when game mode changes
        gameModeSelect.addEventListener('change', () => {
            aiLevelContainer.style.display = gameModeSelect.value === 'player-vs-ai' ? 'block' : 'none';
        });

        cells.forEach(cell => {
            cell.addEventListener('click', handleCellClick);
        });
        
        function showOptionsMenu() {
            // Returns to the mode selection screen
            gameActive = false;
            optionsMenu.style.display = 'block';
            gameBoardElement.style.display = 'none';
            restartButton.style.display = 'none';
            statusMessage.textContent = 'Select your game mode.';
            resetBoardDisplay();
        }

        function startGame() {
            gameMode = gameModeSelect.value;
            aiLevel = aiLevelSelect.value;

            optionsMenu.style.display = 'none';
            gameBoardElement.style.display = 'grid';
            restartButton.style.display = 'block';

            resetGame();
            
            // If AI is set to start, trigger its move after a delay
            if (gameMode === 'player-vs-ai' && currentPlayer === 'O') {
                statusMessage.textContent = 'Computer is thinking...';
                setTimeout(handleAIMove, 800); 
            }
        }

        function resetBoardDisplay() {
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('x', 'o');
            });
        }
        
        function resetGame() {
            board = ['', '', '', '', '', '', '', '', ''];
            currentPlayer = 'X';
            gameActive = true;
            statusMessage.textContent = `${currentPlayer}'s turn`;
            resetBoardDisplay();
        }

        function handleCellClick(event) {
            const clickedCell = event.target;
            const clickedCellIndex = parseInt(clickedCell.getAttribute('data-cell-index'));

            // Guard against invalid moves: game inactive, cell occupied, or it's the AI's turn
            if (board[clickedCellIndex] !== '' || !gameActive || (gameMode === 'player-vs-ai' && currentPlayer === 'O')) {
                return;
            }

            makeMove(clickedCell, clickedCellIndex);

            // If game is still active AND it's Player vs AI, trigger AI move
            if (gameActive && gameMode === 'player-vs-ai') {
                statusMessage.textContent = 'Computer is thinking...';
                setTimeout(handleAIMove, 800);
            }
        }

        function makeMove(cellElement, index) {
            board[index] = currentPlayer;
            cellElement.textContent = currentPlayer;
            cellElement.classList.add(currentPlayer.toLowerCase());

            // 1. Check for Win
            if (checkResult(board, currentPlayer)) {
                gameActive = false;
                statusMessage.textContent = `${currentPlayer} has won!`;
                return; 
            }

            // 2. Check for Draw
            if (!board.includes('')) {
                gameActive = false;
                statusMessage.textContent = 'It\'s a Draw!';
                return;
            }

            // 3. Switch Player
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            statusMessage.textContent = `${currentPlayer}'s turn`;
        }
        
        // Helper to check if a specific player has won on a specific board state
        function checkResult(testBoard, player) {
            return winningConditions.some(condition => {
                return condition.every(index => testBoard[index] === player);
            });
        }

        // --- AI Logic Functions ---

        function handleAIMove() {
            if (!gameActive || currentPlayer !== 'O') return;

            let move;
            
            if (aiLevel === 'easy') {
                move = getEasyMove(board);
            } else if (aiLevel === 'medium') {
                move = getMediumMove(board);
            } else if (aiLevel === 'hard') {
                // Hard level uses the MiniMax algorithm (unbeatable)
                move = getBestMove(board);
            }

            if (move !== undefined) {
                const cellElement = document.querySelector(`[data-cell-index="${move}"]`);
                makeMove(cellElement, move);
            }
        }

        function getAvailableSpots(currentBoard) {
            return currentBoard
                .map((cell, index) => (cell === '' ? index : null))
                .filter(index => index !== null);
        }

        // Level: EASY (Random move)
        function getEasyMove(currentBoard) {
            const available = getAvailableSpots(currentBoard);
            const randomIndex = Math.floor(Math.random() * available.length);
            return available[randomIndex];
        }

        // Level: MEDIUM (Checks for immediate win/block, then random)
        function getMediumMove(currentBoard) {
            const available = getAvailableSpots(currentBoard);
            
            // 1. Check for immediate win (AI is 'O')
            for (const index of available) {
                let tempBoard = [...currentBoard];
                tempBoard[index] = 'O'; 
                if (checkResult(tempBoard, 'O')) {
                    return index;
                }
            }

            // 2. Check for immediate player block (Player is 'X')
            for (const index of available) {
                let tempBoard = [...currentBoard];
                tempBoard[index] = 'X'; 
                if (checkResult(tempBoard, 'X')) {
                    return index;
                }
            }

            // 3. Fallback to Easy move (random)
            return getEasyMove(currentBoard);
        }

        // Level: HARD (Unbeatable - MiniMax Algorithm)
        function getBestMove(currentBoard) {
            // Pick center if available for a classic Tic-Tac-Toe opening
            if (currentBoard[4] === '') { return 4; }
            
            // Find the best move using minimax
            const bestMove = minimax(currentBoard, 'O').index;
            return bestMove;
        }

        // Minimax implementation (Core of the Hard AI)
        function minimax(newBoard, player) {
            const availableSpots = getAvailableSpots(newBoard);

            // Terminal states: Score for X (Opponent) and O (AI)
            if (checkResult(newBoard, 'X')) { return { score: -10 }; }
            if (checkResult(newBoard, 'O')) { return { score: 10 }; }
            if (availableSpots.length === 0) { return { score: 0 }; }

            const moves = [];

            for (let i = 0; i < availableSpots.length; i++) {
                const move = {};
                move.index = availableSpots[i];
                newBoard[availableSpots[i]] = player;

                if (player === 'O') {
                    // Maximize score (AI is maximizing player)
                    move.score = minimax(newBoard, 'X').score;
                } else {
                    // Minimize score (Opponent is minimizing player)
                    move.score = minimax(newBoard, 'O').score;
                }

                newBoard[availableSpots[i]] = ''; // Reset the board spot
                moves.push(move);
            }

            let bestMove;
            if (player === 'O') { // AI (Maximizer)
                let bestScore = -Infinity;
                for (const m of moves) {
                    if (m.score > bestScore) {
                        bestScore = m.score;
                        bestMove = m;
                    }
                }
            } else { // Opponent (Minimizer)
                let bestScore = Infinity;
                for (const m of moves) {
                    if (m.score < bestScore) {
                        bestScore = m.score;
                        bestMove = m;
                    }
                }
            }
            return bestMove;
        }

    </script>
</body>
</html>
